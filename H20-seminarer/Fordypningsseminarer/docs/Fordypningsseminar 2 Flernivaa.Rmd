---
title: "R fordypningsseminar 2: Flernivåanalyse"
output: 
  html_document:
    keep_md: yes
    self_contained: no
    keep_html: no
---
## Flernivåanalyse

Den statistiske motivasjonen bak flernivåanalyse er å ta hensyn til
avhengighet mellom observasjoner i en hierarkisk struktur. *I R:* Som de
andre regresjonsformene vi har sett på, ligner syntaksen for
flernivåanalyse på syntaksen for ols. Den største forskjellen ligger i
spesifisering av nivå for variabler. Hensikten med dette dokumentet er å
hjelpe deg til å forstå hvordan du kan oversette teorien fra
forelesning/pensum om variabler på ulike nivå til R-syntaks i `lmer()`
funksjonen fra pakken `lme4`. Dersom du ikke helt forstår hva som skjer
i flernivå-scriptet, vil forhåpentligvis dette dokumentet være til
hjelp, og vice versa. Installer og last inn `lme4` med koden under.

```{r}
# install.packages("lme4")
library(lme4) # For å kjøre flernivåmodeller
library(tidyverse)
library(stargazer) # For pene tabeller
```

I dag og på torsdag/fredag skal vi bruke et datasett fra European Social Survey. Observasjonene i datasettet er individer og disse er nøsted innad i land. Nivå 1-enhetene vår er altså individer, mens nivå 2-enhetene er land i Europa. Datasettet ligger på github. Last ned datasettet og last det inn i Rstudio. 

```{r}
# Laster inn Rdata
load("../data/ess.rda") # Her må du bytte ut mappestien "../data/" med stien til mappen du lagret data i

str(ess)

```

Datasettet inneholder følgende variabler: 

- `id`: observasjonens id-nummer
- `cntry`: landforkortelse
- `country`: land
- `gender`: kjønn
- `age`: alder
- `income_feel`: "Feeling about household's income nowadays"
- `incomde_decil`: inntektsdesil
- `trust_parl`: "Trust in country's parliament"
- `trust_legalsys`: "Trust in legal system"
- `trust_police`: "Trust in police"
- `trust_polparties`: "Trust in political parties"
- `trust_eurparl`: "Trust in the European Parliament"
- `trust_unitednations`: "Trust in the United Nations" 

ESS dataene i dette formatet kommer med labels. Det kan være et nyttig supplement til kodeboken. En pakke som er fin å installere dersom datasettet du skal bruke har labels er `sjlabelled`. Vi installerer og laster inn pakken før vi ser nærmere på labels ved hjelp av funksjonen `get_label` og `get_labels`: 

```{r}
# install.packages("sjlabelled")
library(sjlabelled)

get_label(ess$trust_eurparl)
summary(ess$trust_eurparl)
get_labels(ess$trust_eurparl)
```

Som vi ser forteller `get_label()` oss hvilket spørsmål som er stilt, mens `get_labels()` forteller oss hva som er laveste og høyeste verdi på variabelen. Her ser vi at variabelen `trust_eurparl` går fra 0-10, og `get_labels()` forteller oss at 0 betyr "No trust at all", mens 10 betyr "Complete trust". Du kan selv sjekke hva som gjelder for noen av de andre variablene. 

## Flernivåanalyse i R
Under finner dere syntaksen for flernivå med samme notasjon som på
forelesning, oversatt til `lmer`. Jeg bruker `group_var` for å betegne
variabelen som forteller hvilken gruppe observasjoner tilhører (den
hierarkiske strukturen). `x` refererer til variabler på nivå 1, mens `z`
referer til variabler på nivå 2 (skiller mellom z og x for å gjøre det
lettere og oversette til **R**).

**Flernivå med kun random intercept:**
\[Y_i = \beta_{0} + u_{0j} + e_{ij}\] 
`lmer(y ~ 1 + (1|group_var), data = data)`

**Flernivå med uavh. variabel på nivå 1, fixed effects, random intercept:** 
\[Y_i = \beta_{0} + \beta_{1}X_{1ij} +  u_{0j} + e_{ij}\]
`lmer(y ~ (1|group_var) + x1, data = data)` 

**Flernivå med uavh. variabel på nivå1, random slopes:**
\[Y_i = \beta_{0} + \beta_{1}X_{1ij} + u_{1j}X_{1ij} + u_{0j} +  e_{ij}\]
`lmer(y ~ x1 + (x1|group_var), data=data)`

**Flernivå med uavh. var på mikronivå med random effects, og uavhengig variabel på makronivå:**
\[Y_i = \beta_{0} + \beta_{1}X_{1ij} + \beta_{2j} Z_{2j} + + u_{1j}X_{1ij} + u_{0j} + e_{ij}\]
`lmer(y ~ x1 + (x1|group_var) + z2, data=data)`

**Flernivå med uavh. var på mikronivå med random effects, kryssnivåsamspill, og uavhengig variabel på makronivå:**
\[Y_i = \beta_{0} + \beta_{1}X_{1ij} + \beta_{2j}Z_{2j} + \beta_{3}X_{1ij}Z_{2j} + + u_{1j}X_{1ij} + u_{0j} + e_{ij}\]
`lmer(y ~ x1*z2 + x1 + (x1|group_var) + z2, data=data)`

### Beregne intraklassekorrelasjon
I forelesning kommer dere til å snakke om noe som heter intra-class correlation. Intra-class correlation forteller oss hvor stor andel av total varians som ligger på nivå 2, i vårt tilfelle på landnivå. Resten av variansen skyldes at nivå 1-enhetene, i vårt tilfelle personer, avviker fra nivå 2-gjennomsnittet. Intra-class correlation kan tolkes som graden av avhengighet mellom enhetene. 

For å finne intra-class correlation så kan vi bruke modellen med kun random intercept. Vi kjører først modellen:

```{r}
m0 <- lmer(data = ess, 
           trust_politicians ~ (1|country))
```

Dersom vi har brukt `lmer()` til å kjøre en flernivåmodell med kun
random intercept, får vi outputen vi trenger til å regne ut ICC etter
denne formelen med `summary()`. For å finne intra-class correlation så deler vi
varians på nivå 2 på summen av varians på nivå en og nivå 2:

\[var(u_j)/(var(u_j) + var(e_{ij}))\]

I vårt eksempel blir det: 
```{r}
summary(m0)

# ICC
1.220/(1.220 + 4.749)
```
Vi kan også bruke `VarCorr(model, comp=`Variance`)`. 

```{r}
# Vi lagrer først et element med de estimerte variansene
m0var <- VarCorr(m0)

# Så bruker vi print() og ber om å få varians
print(m0var, comp = "Variance")
```
I vårt eksempel ligger altså 20 % av variansen på nivå 2 (landnivå). 

**Flernivå med uavh. variabel på nivå 1, fixed effects, random intercept:** 

```{r}
m1 <- lmer(data = ess, 
           trust_politicians ~ (1|country) + gender)

summary(m1)
```
**Flernivå med uavh. variabel på nivå 1, random slopes:**
\[Y_i = \beta_{0} + \beta_{1}X_{1ij} + u_{1j}X_{1ij} + u_{0j} +  e_{ij}\]
`lmer(y ~ x1 + (x1|group_var), data=data)`

```{r}
m2 <- lmer(data = ess, 
           trust_politicians ~ (gender|country) + gender)

summary(m2)
stargazer(m0, m1, m2, type = "text")
```

Før vi ser nærmere på de andre variablene så skal vi hente inn litt informasjon på landnivå. Jeg har lastet ned informasjon om gini-koeffisienten i ulike land i 2016. Gini-koeffisienten er et mål på inntekstulikhet. Jeg laster inn OECD-datasettet og lagrer det som `gini` i Environment.

```{r}
gini <- read.csv("../data/OECD_gini.csv") 
str(gini)

# cntry i gini-dataene ligner på cntry i ess

str(ess)

```
For å kombinere `gini`-dataene med `ess`-dataene så må vi ha en felles nøkkelvariabel som knytter observasjonene sammen. `cntry`-variablene i de to datasettene ligner på hverandre, men mens OECD bruker tre bokstaver i navnforkortelsen så bruker bare ESS bare to. Dette er ofte tilfellet når en forsøker å slå sammen data fra ulike kilder. Det finnes en pakke i R som heter `countrycode` som kan hjelpe oss med dette. Funksjonen `countrycode()` lar oss omkode landforkortelse fra en type til en annen. Vi laster inn pakken. Hvis ikke du har brukt den før så må du først installere den ved hjelp av `install.packages()`-funksjonen. 

```{r}
# install.packages("countrycode")
library(countrycode)
```

Om du skriver `?codelist` så får du en oversikt over de ulike landforkortelsene som finnes i pakken. Jeg har kikket gjennom på forhånd og funnet ut at `iso3c` ser ut til å matche godt med forkortelsene i OECD-dataene og `iso2c` ser ut til å passe godt med ESS-dataene. Denne informasjonen bruker jeg til å lage en ny variabel `cntry2` i OECD-dataene (`gini`). Til slutt bruker jeg denne til å slå sammen de to datasettene.  

```{r}
# Lager ny landkodevariabel
gini$cntry2 <- countrycode(gini$cntry, "iso3c", "iso2c")

# Slår sammen datasettene
ess2 <- ess %>% 
  left_join(gini, by = c("cntry" = "cntry2"))

# Sjekker om alle land har fått en giniverdi ved hjelp av is.na
table(is.na(ess2$gini))

# Dette ser fint ut
```
Nå som vi har slått sammen datasettene så kan vi også kjøre analyser med variabler på nivå 2 (landnivå her). 


**Flernivå med uavh. var på mikronivå med random effects, og uavhengig variabel på makronivå:**

```{r}
m3 <- lmer(data = ess2, 
           trust_politicians ~  gender + (gender|country) + gini)
```


**Flernivå med uavh. var på mikronivå med random effects, kryssnivåsamspill, og uavhengig variabel på makronivå:**
\[Y_i = \beta_{0} + \beta_{1}X_{1ij} + \beta_{2j}Z_{2j} + \beta_{3}X_{1ij}Z_{2j} + + u_{1j}X_{1ij} + u_{0j} + e_{ij}\]
`lmer(y ~ x1*z2 + x1 + (x1|group_var) + z2, data=data)`

```{r}
m4 <- lmer(data = ess2, 
           trust_politicians ~ gender + (gender|country) + gini + gender*gini)

stargazer(m0,m1,m2,m3,m4, type = "text")
```

Dere kan hente ut random slopes/intercepts med
`ranef()`, mens faste effekter kan hentes ut med `coef()`.

```{r}
# Ser på model 1
ranef(m1)
coef(m1)

# Random slopes i ranef() tilsvarer differensansen mellom interceptene vi får med coef()
``` 

## PLOTTE EFFEKTER? 
```{r}
library(sjPlot)
plot_model(m3, type = "pred")
plot(m4)
```


## Flernivå i hjemmeoppgaven? 
Her er en mer utdypende [forklaring av lme4 pakken med eksempler](https://cran.r-project.org/web/packages/lme4/vignettes/lmer.pdf).
Mye av teksten er teknisk, men se seksjon 5.2 dersom du tenker å kjøre en flernivåanalyse til hjemmeoppgaven for detaljer om diagnostikk for
`lmer`.
